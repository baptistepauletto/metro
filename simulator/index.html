<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LED Matrix Simulator - 64√ó32</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #666;
            padding: 20px;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            padding: 20px 0;
            max-width: 1400px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .info {
            text-align: left;
            font-size: 14px;
            color: #444;
        }
        
        .info h1 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #888;
        }
        
        .info p {
            margin: 5px 0;
            color: #666;
        }
        
        /* LED Matrix Container */
        .matrix-container {
            background: #000;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
            transform-origin: top center;
            margin: 20px 0;
        }
        
        /* 64x32 LED Grid */
        .led-matrix {
            display: grid;
            grid-template-columns: repeat(64, 1fr);
            grid-template-rows: repeat(32, 1fr);
            gap: 2px;
            background: #000;
            padding: 8px;
            border: 2px solid #1a1a1a;
        }
        
        /* Individual LED */
        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #0a0a0a;
            box-shadow: inset 0 0 2px rgba(0, 0, 0, 0.5);
        }
        
        /* LED On state with glow */
        .led.on {
            background: var(--led-color, #ff6b00);
            box-shadow: 
                0 0 4px var(--led-color, #ff6b00),
                0 0 8px var(--led-color, #ff6b00),
                inset 0 0 4px rgba(255, 255, 255, 0.5);
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }
        
        input[type="file"] {
            display: none;
        }
        
        button, .file-button {
            background: #1a1a1a;
            color: #888;
            border: 1px solid #333;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-family: inherit;
            transition: all 0.2s;
        }
        
        button:hover, .file-button:hover {
            background: #222;
            border-color: #555;
            color: #aaa;
        }
        
        input[type="number"] {
            background: #1a1a1a;
            color: #888;
            border: 1px solid #333;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            width: 80px;
            font-family: inherit;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            background: #1a1a1a;
            border: 1px solid #333;
        }
        
        .status.success {
            color: #0f0;
            border-color: #0f0;
        }
        
        .status.error {
            color: #f00;
            border-color: #f00;
        }
        
        .status.info {
            color: #0af;
            border-color: #0af;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="info">
                <h1>üöá LED Matrix Simulator (64√ó32)</h1>
                <p id="statusText" class="status info">Load schedule.json for live countdown, or use Test Minutes</p>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>Load Schedule</label>
                    <label for="fileInput" class="file-button">üìÅ Choose File</label>
                    <input type="file" id="fileInput" accept=".json">
                </div>
                
                <div class="control-group">
                    <label>Test Minutes</label>
                    <input type="number" id="minutesInput" min="0" max="99" value="5" placeholder="Minutes">
                </div>
                
                <div class="control-group">
                    <label>Scale</label>
                    <input type="range" id="scaleSlider" min="0.5" max="3" step="0.1" value="2">
                    <span id="scaleValue" style="font-size: 11px; color: #666;">200%</span>
                </div>
            </div>
        </div>
        
        <div class="matrix-container">
            <div class="led-matrix" id="matrix"></div>
        </div>
        
        <div class="info" style="text-align: center; margin-top: 20px;">
            <p style="color: #888;">This simulator shows exactly what will appear on your Matrix Portal hardware</p>
        </div>
    </div>

    <script>
        // Configuration
        const MATRIX_WIDTH = 64;
        const MATRIX_HEIGHT = 32;
        
        // State
        let matrix = [];
        let scheduleData = null;
        let currentStation = "ROSEMONT";
        let currentLine = "2";
        
        // Line colors (RGB for LED matrix)
        const LINE_COLORS = {
            "1": { r: 0, g: 179, b: 0 },      // Green
            "2": { r: 217, g: 87, b: 0 },     // Orange  
            "4": { r: 255, g: 217, b: 0 },    // Yellow
            "5": { r: 0, g: 149, b: 230 },    // Blue
        };
        
        // 5x7 pixel font
        const FONT_5X7 = {
            '0': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,1,1],[1,0,1,0,1],[1,1,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '1': [[0,0,1,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,1,1,1,0]],
            '2': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],
            '3': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '4': [[0,0,0,1,0],[0,0,1,1,0],[0,1,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0],[0,0,0,1,0]],
            '5': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '6': [[0,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '7': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0]],
            '8': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            '9': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[0,0,0,0,1],[0,1,1,1,0]],
            'R': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
            'O': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'S': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
            'E': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
            'M': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
            'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
            'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
            '-': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
            ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
        };
        
        // Initialize matrix
        function initMatrix() {
            const matrixEl = document.getElementById('matrix');
            matrixEl.innerHTML = '';
            matrix = [];
            
            for (let y = 0; y < MATRIX_HEIGHT; y++) {
                matrix[y] = [];
                for (let x = 0; x < MATRIX_WIDTH; x++) {
                    const led = document.createElement('div');
                    led.className = 'led';
                    matrixEl.appendChild(led);
                    matrix[y][x] = led;
                }
            }
        }
        
        // Clear matrix
        function clearMatrix() {
            for (let y = 0; y < MATRIX_HEIGHT; y++) {
                for (let x = 0; x < MATRIX_WIDTH; x++) {
                    setPixel(x, y, 0, 0, 0);
                }
            }
        }
        
        // Set individual pixel
        function setPixel(x, y, r, g, b) {
            if (x < 0 || x >= MATRIX_WIDTH || y < 0 || y >= MATRIX_HEIGHT) return;
            
            const led = matrix[y][x];
            
            if (r === 0 && g === 0 && b === 0) {
                led.className = 'led';
            } else {
                const color = `rgb(${r}, ${g}, ${b})`;
                led.style.setProperty('--led-color', color);
                led.className = 'led on';
            }
        }
        
        // Draw character at position
        function drawChar(char, x, y, r, g, b) {
            const glyph = FONT_5X7[char.toUpperCase()];
            if (!glyph) return 5;
            
            for (let dy = 0; dy < 7; dy++) {
                for (let dx = 0; dx < 5; dx++) {
                    if (glyph[dy][dx]) {
                        setPixel(x + dx, y + dy, r, g, b);
                    }
                }
            }
            return 5;
        }
        
        // Draw text at position
        function drawText(text, x, y, r, g, b, spacing = 1) {
            let currentX = x;
            for (let i = 0; i < text.length; i++) {
                const charWidth = drawChar(text[i], currentX, y, r, g, b);
                currentX += charWidth + spacing;
            }
        }
        
        // Draw filled rectangle
        function fillRect(x, y, width, height, r, g, b) {
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    setPixel(x + dx, y + dy, r, g, b);
                }
            }
        }
        
        // Render display
        function renderDisplay(minutes, stationName, lineNumber) {
            clearMatrix();
            
            const color = LINE_COLORS[lineNumber] || LINE_COLORS["2"];
            
            // Truncate station name if too long
            if (stationName.length > 10) {
                stationName = stationName.substring(0, 10);
            }
            
            // Draw station name at top (centered)
            const stationWidth = stationName.length * 6 - 1;
            const stationX = Math.floor((MATRIX_WIDTH - stationWidth) / 2);
            drawText(stationName, stationX, 1, color.r, color.g, color.b, 1);
            
            // Draw line indicator (colored bar)
            fillRect(0, 9, MATRIX_WIDTH, 1, color.r, color.g, color.b);
            
            // Draw countdown number (large, centered)
            const minutesStr = String(Math.min(minutes, 99));
            const totalWidth = minutesStr.length * 6 - 1;
            const numX = Math.floor((MATRIX_WIDTH - totalWidth) / 2);
            drawText(minutesStr, numX, 13, 
                     Math.floor(color.r * 0.9), 
                     Math.floor(color.g * 0.9), 
                     Math.floor(color.b * 0.9), 1);
            
            // Draw "MIN" at bottom
            const minWidth = 3 * 6 - 1;
            const minX = Math.floor((MATRIX_WIDTH - minWidth) / 2);
            drawText("MIN", minX, 24, 
                     Math.floor(color.r * 0.4), 
                     Math.floor(color.g * 0.4), 
                     Math.floor(color.b * 0.4), 1);
        }
        
        // Update status
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('statusText');
            status.textContent = message;
            status.className = `status ${type}`;
        }
        
        // Get current day of week
        function getCurrentDay() {
            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            return days[new Date().getDay()];
        }
        
        // Get current time as HH:MM
        function getCurrentTime() {
            const now = new Date();
            return `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        }
        
        // Find next departure from schedule
        function findNextDeparture(schedule) {
            if (!schedule) return null;
            
            const currentDay = getCurrentDay();
            const currentTime = getCurrentTime();
            const todayDepartures = schedule.schedule[currentDay] || [];
            
            // Find next departure today
            for (let departure of todayDepartures) {
                if (departure > currentTime) {
                    // Calculate minutes until departure
                    const [currH, currM] = currentTime.split(':').map(Number);
                    const [depH, depM] = departure.split(':').map(Number);
                    
                    const currMinutes = currH * 60 + currM;
                    const depMinutes = depH * 60 + depM;
                    
                    return {
                        time: departure,
                        minutes: depMinutes - currMinutes
                    };
                }
            }
            
            // No more departures today - check tomorrow
            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            const tomorrowIndex = (days.indexOf(currentDay) + 1) % 7;
            const tomorrow = days[tomorrowIndex];
            const tomorrowDepartures = schedule.schedule[tomorrow] || [];
            
            if (tomorrowDepartures.length > 0) {
                const [currH, currM] = currentTime.split(':').map(Number);
                const [depH, depM] = tomorrowDepartures[0].split(':').map(Number);
                
                const currMinutes = currH * 60 + currM;
                const minutesUntilMidnight = (24 * 60) - currMinutes;
                const minutesAfterMidnight = depH * 60 + depM;
                
                return {
                    time: tomorrowDepartures[0],
                    minutes: minutesUntilMidnight + minutesAfterMidnight
                };
            }
            
            return null;
        }
        
        // Auto-update display with real countdown
        function autoUpdateDisplay() {
            if (scheduleData) {
                const next = findNextDeparture(scheduleData);
                if (next) {
                    renderDisplay(next.minutes, currentStation, currentLine);
                    updateStatus(`Next: ${next.time} (${next.minutes} min) ‚Ä¢ Auto-updating`, 'success');
                } else {
                    renderDisplay(0, currentStation, currentLine);
                    updateStatus('No departures found', 'error');
                }
            }
        }
        
        // Load schedule file
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    scheduleData = JSON.parse(event.target.result);
                    currentStation = scheduleData.station || "METRO";
                    currentLine = scheduleData.line || "2";
                    
                    // Update display with real countdown
                    autoUpdateDisplay();
                    
                } catch (error) {
                    updateStatus('‚ùå Error: Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
        });
        
        // Test minutes input (manual override)
        document.getElementById('minutesInput').addEventListener('input', (e) => {
            const minutes = parseInt(e.target.value) || 0;
            renderDisplay(minutes, currentStation, currentLine);
            
            if (scheduleData) {
                updateStatus(`Manual test mode: ${minutes} min (auto-update paused)`, 'info');
            } else {
                updateStatus(`Test mode: ${minutes} min`, 'info');
            }
        });
        
        // Resume auto-update when input loses focus
        document.getElementById('minutesInput').addEventListener('blur', () => {
            if (scheduleData) {
                setTimeout(() => autoUpdateDisplay(), 1000);
            }
        });
        
        // Scale control
        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            const scale = parseFloat(e.target.value);
            document.querySelector('.matrix-container').style.transform = `scale(${scale})`;
            document.getElementById('scaleValue').textContent = `${Math.round(scale * 100)}%`;
        });
        
        // Initialize
        initMatrix();
        renderDisplay(5, currentStation, currentLine);
        
        // Set initial scale
        document.querySelector('.matrix-container').style.transform = 'scale(2)';
        
        // Auto-update every 30 seconds if schedule is loaded
        setInterval(() => {
            if (scheduleData) {
                autoUpdateDisplay();
            }
        }, 30000);  // Update every 30 seconds
    </script>
</body>
</html>
